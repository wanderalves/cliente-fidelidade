// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
import { isArray, isDateValid } from '../utils/type-checks';
import { isAfter, isBefore } from '../utils/date-compare';
function pickBy(fn, dates) {
    let _dates;
    const _firstArg = dates[0];
    if (isArray(_firstArg) && dates.length === 1) {
        _dates = _firstArg;
    }
    else if (isArray(dates)) {
        _dates = dates;
    }
    if (!_dates || !_dates.length) {
        return new Date();
    }
    let res = _dates[0];
    for (let i = 1; i < _dates.length; ++i) {
        // if (!moments[i].isValid() || moments[i][fn](res)) {
        if (!isDateValid(_dates[i]) || fn.call(null, _dates[i], res)) {
            res = _dates[i];
        }
    }
    return res;
}
// TODO: Use [].sort instead?
export function min(...args) {
    // const args = [].slice.call(arguments, 0);
    return pickBy(isBefore, args);
}
export function max(...args) {
    // const args = [].slice.call(arguments, 0);
    return pickBy(isAfter, args);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWluLW1heC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9jaHJvbm9zL21vbWVudC9taW4tbWF4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG9FQUFvRTtBQUNwRSwwREFBMEQ7QUFDMUQsRUFBRTtBQUNGLHlFQUF5RTtBQUN6RSwrQ0FBK0M7QUFDL0MsT0FBTyxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUM1RCxPQUFPLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRzFELFNBQVMsTUFBTSxDQUFDLEVBQTBELEVBQUUsS0FBd0I7SUFDbEcsSUFBSSxNQUFjLENBQUM7SUFDbkIsTUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNCLElBQUksT0FBTyxDQUFPLFNBQVMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7UUFDbkQsTUFBTSxHQUFHLFNBQVMsQ0FBQztJQUNyQixDQUFDO1NBQU0sSUFBSSxPQUFPLENBQU8sS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUNoQyxNQUFNLEdBQUcsS0FBSyxDQUFDO0lBQ2pCLENBQUM7SUFFRCxJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQzlCLE9BQU8sSUFBSSxJQUFJLEVBQUUsQ0FBQztJQUNwQixDQUFDO0lBQ0QsSUFBSSxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3BCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFDdkMsc0RBQXNEO1FBQ3RELElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDN0QsR0FBRyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNsQixDQUFDO0lBQ0gsQ0FBQztJQUVELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQUVELDZCQUE2QjtBQUM3QixNQUFNLFVBQVUsR0FBRyxDQUFDLEdBQUcsSUFBWTtJQUNqQyw0Q0FBNEM7SUFFNUMsT0FBTyxNQUFNLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ2hDLENBQUM7QUFFRCxNQUFNLFVBQVUsR0FBRyxDQUFDLEdBQUcsSUFBWTtJQUNqQyw0Q0FBNEM7SUFFNUMsT0FBTyxNQUFNLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQy9CLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQaWNrIGEgbW9tZW50IG0gZnJvbSBtb21lbnRzIHNvIHRoYXQgbVtmbl0ob3RoZXIpIGlzIHRydWUgZm9yIGFsbFxuLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuLy9cbi8vIG1vbWVudHMgc2hvdWxkIGVpdGhlciBiZSBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cyBvciBhbiBhcnJheSwgd2hvc2Vcbi8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG5pbXBvcnQgeyBpc0FycmF5LCBpc0RhdGVWYWxpZCB9IGZyb20gJy4uL3V0aWxzL3R5cGUtY2hlY2tzJztcbmltcG9ydCB7IGlzQWZ0ZXIsIGlzQmVmb3JlIH0gZnJvbSAnLi4vdXRpbHMvZGF0ZS1jb21wYXJlJztcbmltcG9ydCB7IFVuaXRPZlRpbWUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmZ1bmN0aW9uIHBpY2tCeShmbjogKGRhdGU6IERhdGUsIGRhdGUyOiBEYXRlLCB1bml0OiBVbml0T2ZUaW1lKSA9PiBib29sZWFuLCBkYXRlczogRGF0ZVtdIHwgRGF0ZVtdW10pOiBEYXRlIHtcbiAgbGV0IF9kYXRlczogRGF0ZVtdO1xuICBjb25zdCBfZmlyc3RBcmcgPSBkYXRlc1swXTtcbiAgaWYgKGlzQXJyYXk8RGF0ZT4oX2ZpcnN0QXJnKSAmJiBkYXRlcy5sZW5ndGggPT09IDEpIHtcbiAgICBfZGF0ZXMgPSBfZmlyc3RBcmc7XG4gIH0gZWxzZSBpZiAoaXNBcnJheTxEYXRlPihkYXRlcykpIHtcbiAgICBfZGF0ZXMgPSBkYXRlcztcbiAgfVxuXG4gIGlmICghX2RhdGVzIHx8ICFfZGF0ZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gIH1cbiAgbGV0IHJlcyA9IF9kYXRlc1swXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBfZGF0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICBpZiAoIWlzRGF0ZVZhbGlkKF9kYXRlc1tpXSkgfHwgZm4uY2FsbChudWxsLCBfZGF0ZXNbaV0sIHJlcykpIHtcbiAgICAgIHJlcyA9IF9kYXRlc1tpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBUT0RPOiBVc2UgW10uc29ydCBpbnN0ZWFkP1xuZXhwb3J0IGZ1bmN0aW9uIG1pbiguLi5hcmdzOiBEYXRlW10pOiBEYXRlIHtcbiAgLy8gY29uc3QgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICByZXR1cm4gcGlja0J5KGlzQmVmb3JlLCBhcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1heCguLi5hcmdzOiBEYXRlW10pOiBEYXRlIHtcbiAgLy8gY29uc3QgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICByZXR1cm4gcGlja0J5KGlzQWZ0ZXIsIGFyZ3MpO1xufVxuIl19